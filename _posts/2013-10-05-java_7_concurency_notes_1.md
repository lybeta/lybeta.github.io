---
layout: post
title: "Java 7 并发编程学习笔记（1）-- 线程管理（上）"
category: 技术
tags: Concurrency
---

## 线程的创建和运行

与每个Java语言中的元素一样，线程是对象。在Java中，我们有2个方式创建线程：

* 通过直接继承thread类，然后覆盖run()方法。
* 构建一个实现Runnable接口的类, 然后创建一个thread类对象并传递Runnable对象作为构造参数

每个Java程序最少有一个执行线程。当你运行程序的时候, JVM运行负责调用main()方法的执行线程。

当调用Thread对象的start()方法时, 我们创建了另一个执行线程。在这些start()方法调出后，我们的程序就有了多个执行线程。

当全部的线程执行结束时（更具体点，所有非守护线程结束时），Java程序就结束了。如果初始线程（执行main()方法的主线程）运行结束，其他的线程还是会继续执行直到执行完成。但是如果某个线程调用System.exit()指示终结程序，那么全部的线程都会结束执行。

创建一个Thread类的对象不会创建新的执行线程。同样，调用实现Runnable接口的 run()方法也不会创建一个新的执行线程。只有调用start()方法才能创建一个新的执行线程。

<!--more-->

## 获取和设置线程信息

Thread类的对象中保存了一些属性信息能够帮助我们来辨别每一个线程，知道它的状态，调整控制其优先级。 这些属性是：

* ID: 每个线程的独特标识。
* Name: 线程的名称。
* Priority: 线程对象的优先级。优先级别在1-10之间，1是最低级，10是最高级。不建议改变它们的优先级，但是你想的话也是可以的。
* Status: 线程的状态。在Java中，线程只能有这6种中的一种状态： new, runnable, blocked, waiting, time waiting, 或 terminated.

Thread 类有能保存使用线程信息的属性。JVM根据线程的优先级来选择将使用CPU的线程，然后再根据每个线程的情况来实现它们的状态。

如果你没有声明一个线程的名字，那么JVM会自动命名它为：Thread-XX，XX是一个数字。线程的ID或者状态是不可修改的。Thread类没有实现setId()和setStatus()方法来允许修改它们。

**注意**

使用 setPriority() 方法时如果你设置的优先级不是在1-10之间，会抛出 IllegalArgumentException 异常。

## 线程的中断

一个多个线程在执行的Java程序，只有当其全部的线程执行结束时（更具体的说，是所有非守护线程结束或者某个线程调用System.exit()方法的时候），它才会结束运行。有时，你需要为了终止程序而结束一个线程，或者当程序的用户想要取消某个Thread对象正在做的任务。

Java提供中断机制来通知线程表明我们想要结束它。中断机制的特性是线程需要检查是否被中断，而且还可以决定是否响应结束的请求。所以，线程可以忽略中断请求并且继续运行。

Thread 类还有一个boolean类型的属性来表明线程是否被中断。当你调用线程的interrupt() 方法，就代表你把这个属性设置为 true。 而isInterrupted() 方法仅返回属性值。

**注意**

Thread 类还有其他可以检查线程是否被中断的方法。例如，这个静态方法interrupted()能检查正在运行的线程是否被中断。

isInterrupted()和interrupted() 方法有着很重要的区别。

第一个不会改变interrupted属性值，但是第二个会设置成false。

interrupted() 方法是一个静态方法，建议使用isInterrupted()方法。

在之前提到的，线程是可以忽略中断指令的，但是并这不是我们所期望的行为。

## 操作线程的中断机制

如果线程实现的是由复杂的算法分成的一些方法，或者它的方法有递归调用，那么我们可以用更好的机制来控制线程中断。为了这个Java提供了InterruptedException异常。当你检测到程序的中断并在run()方法内捕获，你可以抛这个异常，并继续执行。

**注意**

InterruptedException 异常是由一些与并发API有关的Java方法，如sleep()抛出的。

## 线程的睡眠与恢复

有时, 你会感兴趣在一段确定的时间内中断执行线程。例如, 程序的一个线程每分钟检查反应器状态。其余时间，线程什么也不做。在这段时间，线程不使用任何计算机资源。过了这段时间，当JVM选择它时，线程会准备好继续执行。为达此目的，你可以使用Thread类的 sleep() 方法 。此方法接收一个整数作为参数，表示线程暂停运行的毫秒数。 在调用sleep() 方法后，当时间结束时，当JVM安排他们CPU时间，线程会继续按指令执行。

另一种可能是使用一个有TimeUnit列举元素的sleep() 方法，使用线程类的 sleep() 方法让当前线程睡眠，但是它接收的参数单位是表示并转换成毫秒的。

当你调用sleep()方法， Thread 离开CPU并在一段时间内停止运行。在这段时间内，它是不消耗CPU时间的，使CPU可以执行其他任务。

当 Thread 处于睡眠状态并被中断的时候，那方法会立刻抛出InterruptedException异常，而不会一直等到睡眠时间过去。

**注意**

Java 并发 API 有另一种方法能让线程对象离开 CPU。它是 yield() 方法, 它向JVM表示线程对象可以让CPU执行其他任务。JVM 不保证它会遵守请求。通常，它只是用来试调的。

## 等待线程的终结

在某些情况下，我们需要等待线程的终结。例如，我们可能会遇到程序在执行前需要初始化资源。在执行剩下的代码之前，我们需要等待线程完成初始化任务。

为达此目的, 我们使用Thread 类的join() 方法。当前线程调用某个线程的这个方法时，它会暂停当前线程，直到被调用线程执行完成。

**注意**

Java 提供2种形式的 join() 方法:

* join (long milliseconds)
* join (long milliseconds, long nanos)

第一种join() 方法, 这方法让调用线程等待特定的毫秒数。例如，如果thread1对象使用代码thread2.join(1000), 那么线程 thread1暂停运行，直到以下其中一个条件发生：

* thread2 结束运行
* 1000 毫秒过去了
* 
当其中一个条件为真时，join() 方法返回。

第二个版本的 join() 方法和第一个很像，只不过它接收一个毫秒数和一个纳秒数作为参数。